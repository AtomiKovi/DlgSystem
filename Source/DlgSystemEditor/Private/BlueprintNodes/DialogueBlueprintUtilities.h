// Copyright 2017-2018 Csaba Molnar, Daniel Butum
#pragma once

#include "CoreMinimal.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "EdGraphSchema_K2.h"
#include "SGraphPin.h"

#include "KismetPins/SGraphPinBool.h"
#include "SGraphPinString.h"
#include "SGraphPinObject.h"
#include "KismetPins/SGraphPinExec.h"
#include "SGraphPinNum.h"
#include "SGraphPinInteger.h"
#include "SGraphPinColor.h"
#include "SGraphPinVector.h"
#include "SGraphPinVector2D.h"
#include "SGraphPinVector4.h"

#include "DlgDialogueParticipant.h"
#include "DlgManager.h"

class FDialogueBlueprintUtilities
{
public:
	/**
	 * Tries to get the dialogue name... it expects the owner of the node to implement IDlgDialogueParticipant interface
	 * @return		the participant name on success or NAME_None on failure.
	 */
	static FName GetParticipantNameFromNode(UK2Node* Node)
	{
		// NOTE we can't call Node->GetBlueprint() because this is called in strange places ;)
		if (UEdGraph* Graph = Cast<UEdGraph>(Node->GetOuter()))
		{
			if (UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(Graph))
			{
				if (UDlgManager::DoesObjectImplementDialogueParticipantInterface(Blueprint))
				{
					return IDlgDialogueParticipant::Execute_GetParticipantName(Blueprint->GeneratedClass->GetDefaultObject());
				}
			}
		}

		return NAME_None;
	}

	// Backport of UEdGraphSchema_K2 function with the same name
	static void SetPinAutogeneratedDefaultValueBasedOnType(UEdGraphPin* Pin)
	{
		FString NewValue;

		// Create a useful default value based on the pin type
		if (Pin->PinType.IsContainer())
		{
			NewValue = FString();
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int)
		{
			NewValue = TEXT("0");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte)
		{
			UEnum* EnumPtr = Cast<UEnum>(Pin->PinType.PinSubCategoryObject.Get());
			if (EnumPtr)
			{
				// First element of enum can change. If the enum is { A, B, C } and the default value is A, 
				// the defult value should not change when enum will be changed into { N, A, B, C }
				NewValue = FString();
			}
			else
			{
				NewValue = TEXT("0");
			}
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Float)
		{
			// This is a slightly different format than is produced by PropertyValueToString, but changing it has backward compatibility issues
			NewValue = TEXT("0.0");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
		{
			NewValue = TEXT("false");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name)
		{
			NewValue = TEXT("None");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct)
		{
			// This is a slightly different format than is produced by PropertyValueToString, but changing it has backward compatibility issues
			NewValue = TEXT("0, 0, 0");
		}

		// PropertyValueToString also has cases for LinerColor and Transform, LinearColor is identical to export text so is fine, the Transform case is specially handled in the vm
		Pin->AutogeneratedDefaultValue = NewValue;
	}

	// Backport of FNodeFactory function with the same name
	static TSharedPtr<SGraphPin> CreatePinWidget(UEdGraphPin* InPin)
	{
		check(InPin != NULL);

		if (const UEdGraphSchema_K2* K2Schema = Cast<const UEdGraphSchema_K2>(InPin->GetSchema()))
		{
			if (InPin->PinType.PinCategory == K2Schema->PC_Boolean)
			{
				return SNew(SGraphPinBool, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Exec)
			{
				return SNew(SGraphPinExec, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Object)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Interface)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Asset)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Int)
			{
				return SNew(SGraphPinInteger, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Float)
			{
				return SNew(SGraphPinNum, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_String || InPin->PinType.PinCategory == K2Schema->PC_Name)
			{
				return SNew(SGraphPinString, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Struct)
			{
				// If you update this logic you'll probably need to update UEdGraphSchema_K2::ShouldHidePinDefaultValue!
				UScriptStruct* ColorStruct = TBaseStructure<FLinearColor>::Get();
				UScriptStruct* VectorStruct = TBaseStructure<FVector>::Get();
				UScriptStruct* Vector2DStruct = TBaseStructure<FVector2D>::Get();
				UScriptStruct* RotatorStruct = TBaseStructure<FRotator>::Get();

				if (InPin->PinType.PinSubCategoryObject == ColorStruct)
				{
					return SNew(SGraphPinColor, InPin);
				}
				else if ((InPin->PinType.PinSubCategoryObject == VectorStruct) || (InPin->PinType.PinSubCategoryObject == RotatorStruct))
				{
					return SNew(SGraphPinVector, InPin);
				}
				else if (InPin->PinType.PinSubCategoryObject == Vector2DStruct)
				{
					return SNew(SGraphPinVector2D, InPin);
				}
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Byte)
			{
				// Check for valid enum object reference
				return SNew(SGraphPinInteger, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_MCDelegate)
			{
				return SNew(SGraphPinString, InPin);
			}
		}

		// If we didn't pick a custom pin widget, use an uncustomized basic pin
		return SNew(SGraphPin, InPin);
	}
};
