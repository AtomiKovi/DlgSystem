// Copyright 2017-2018 Csaba Molnar, Daniel Butum
#pragma once

#include "CoreMinimal.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "EdGraphSchema_K2.h"
#include "SGraphPin.h"
#include "UObject/ConstructorHelpers.h"
#include "Internationalization/TextPackageNamespaceUtil.h"
#include "Misc/PackageName.h"
#include "KismetPins/SGraphPinBool.h"
#include "SGraphPinString.h"
#include "SGraphPinObject.h"
#include "KismetPins/SGraphPinExec.h"
#include "SGraphPinNum.h"
#include "SGraphPinInteger.h"
#include "SGraphPinColor.h"
#include "SGraphPinVector.h"
#include "SGraphPinVector2D.h"
#include "SGraphPinVector4.h"

#include "DlgDialogueParticipant.h"
#include "DlgManager.h"

class FDialogueBlueprintUtilities
{
public:
	/**
	 * Tries to get the dialogue name... it expects the owner of the node to implement IDlgDialogueParticipant interface
	 * @return		the participant name on success or NAME_None on failure.
	 */
	static FName GetParticipantNameFromNode(UK2Node* Node)
	{
		// NOTE we can't call Node->GetBlueprint() because this is called in strange places ;)
		if (UEdGraph* Graph = Cast<UEdGraph>(Node->GetOuter()))
		{
			if (UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(Graph))
			{
				if (UDlgManager::DoesObjectImplementDialogueParticipantInterface(Blueprint))
				{
					return IDlgDialogueParticipant::Execute_GetParticipantName(Blueprint->GeneratedClass->GetDefaultObject());
				}
			}
		}

		return NAME_None;
	}

	// Backport of UEdGraphSchema_K2 function with the same name
	static void SetPinAutogeneratedDefaultValueBasedOnType(UEdGraphPin* Pin)
	{
		FString NewValue;

		// Create a useful default value based on the pin type
		if (Pin->PinType.IsContainer())
		{
			NewValue = FString();
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int)
		{
			NewValue = TEXT("0");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte)
		{
			UEnum* EnumPtr = Cast<UEnum>(Pin->PinType.PinSubCategoryObject.Get());
			if (EnumPtr)
			{
				// First element of enum can change. If the enum is { A, B, C } and the default value is A, 
				// the defult value should not change when enum will be changed into { N, A, B, C }
				NewValue = FString();
			}
			else
			{
				NewValue = TEXT("0");
			}
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Float)
		{
			// This is a slightly different format than is produced by PropertyValueToString, but changing it has backward compatibility issues
			NewValue = TEXT("0.0");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
		{
			NewValue = TEXT("false");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name)
		{
			NewValue = TEXT("None");
		}
		else if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Struct)
		{
			// This is a slightly different format than is produced by PropertyValueToString, but changing it has backward compatibility issues
			NewValue = TEXT("0, 0, 0");
		}

		// PropertyValueToString also has cases for LinerColor and Transform, LinearColor is identical to export text so is fine, the Transform case is specially handled in the vm
		Pin->AutogeneratedDefaultValue = NewValue;
	}

	// Backport of UEdGraphSchema_K2 function with the same name
	static void ResetPinToAutogeneratedDefaultValue(UEdGraphPin* Pin, bool bCallModifyCallbacks = true)
	{
		FDialogueBlueprintUtilities::GetPinDefaultValuesFromString(Pin->PinType, Pin->GetOwningNodeUnchecked(), Pin->AutogeneratedDefaultValue, Pin->DefaultValue, Pin->DefaultObject, Pin->DefaultTextValue);

		if (bCallModifyCallbacks)
		{
			UEdGraphNode* Node = Pin->GetOwningNode();
			Node->PinDefaultValueChanged(Pin);

			if (UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForNode(Node))
			{
				FBlueprintEditorUtils::MarkBlueprintAsModified(Blueprint);
			}
		}
	}

	// Backport of UEdGraphSchema_K2 function with the same name
	static void GetPinDefaultValuesFromString(const FEdGraphPinType& PinType, UObject* OwningObject, const FString& NewDefaultValue, FString& UseDefaultValue, UObject*& UseDefaultObject, FText& UseDefaultText)
	{
		if ((PinType.PinCategory == UEdGraphSchema_K2::PC_Object)
			|| (PinType.PinCategory == UEdGraphSchema_K2::PC_Class)
			|| (PinType.PinCategory == UEdGraphSchema_K2::PC_Interface))
		{
			FString ObjectPathLocal = NewDefaultValue;
			ConstructorHelpers::StripObjectClass(ObjectPathLocal);

			// If this is not a full object path it's a relative path so should be saved as a string
			if (FPackageName::IsValidLongPackageName(ObjectPathLocal))
			{
				FStringAssetReference AssetRef = ObjectPathLocal;
				UseDefaultValue.Empty();
				UseDefaultObject = AssetRef.TryLoad();
				UseDefaultText = FText::GetEmpty();
			}
			else
			{
				// "None" should be saved as empty string
				if (ObjectPathLocal == TEXT("None"))
				{
					ObjectPathLocal.Empty();
				}

				UseDefaultValue = ObjectPathLocal;
				UseDefaultObject = nullptr;
				UseDefaultText = FText::GetEmpty();
			}
		}
		else if (PinType.PinCategory == UEdGraphSchema_K2::PC_Text)
		{
			FString PackageNamespace;
#if USE_STABLE_LOCALIZATION_KEYS
			if (GIsEditor)
			{
				PackageNamespace = TextNamespaceUtil::EnsurePackageNamespace(OwningObject);
			}
#endif // USE_STABLE_LOCALIZATION_KEYS
			if (!FTextStringHelper::ReadFromString(*NewDefaultValue, UseDefaultText, nullptr, *PackageNamespace))
			{
				UseDefaultText = FText::FromString(NewDefaultValue);
			}
			UseDefaultObject = nullptr;
			UseDefaultValue.Empty();
		}
		else
		{
			UseDefaultValue = NewDefaultValue;
			UseDefaultObject = nullptr;
			UseDefaultText = FText::GetEmpty();

			if (PinType.PinCategory == UEdGraphSchema_K2::PC_Byte && UseDefaultValue.IsEmpty())
			{
				UEnum* EnumPtr = Cast<UEnum>(PinType.PinSubCategoryObject.Get());
				if (EnumPtr)
				{
					// Enums are stored as empty string in autogenerated defaults, but should turn into the first value in array 
					UseDefaultValue = EnumPtr->GetNameStringByIndex(0);
				}
			}
			else if ((PinType.PinCategory == UEdGraphSchema_K2::PC_Asset) || (PinType.PinCategory == UEdGraphSchema_K2::PC_AssetClass))
			{
				ConstructorHelpers::StripObjectClass(UseDefaultValue);
			}
		}
	}

	// Backport of FNodeFactory function with the same name
	static TSharedPtr<SGraphPin> CreatePinWidget(UEdGraphPin* InPin)
	{
		check(InPin != NULL);

		if (const UEdGraphSchema_K2* K2Schema = Cast<const UEdGraphSchema_K2>(InPin->GetSchema()))
		{
			if (InPin->PinType.PinCategory == K2Schema->PC_Boolean)
			{
				return SNew(SGraphPinBool, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Exec)
			{
				return SNew(SGraphPinExec, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Object)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Interface)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Asset)
			{
				return SNew(SGraphPinObject, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Int)
			{
				return SNew(SGraphPinInteger, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Float)
			{
				return SNew(SGraphPinNum, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_String || InPin->PinType.PinCategory == K2Schema->PC_Name)
			{
				return SNew(SGraphPinString, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Struct)
			{
				// If you update this logic you'll probably need to update UEdGraphSchema_K2::ShouldHidePinDefaultValue!
				UScriptStruct* ColorStruct = TBaseStructure<FLinearColor>::Get();
				UScriptStruct* VectorStruct = TBaseStructure<FVector>::Get();
				UScriptStruct* Vector2DStruct = TBaseStructure<FVector2D>::Get();
				UScriptStruct* RotatorStruct = TBaseStructure<FRotator>::Get();

				if (InPin->PinType.PinSubCategoryObject == ColorStruct)
				{
					return SNew(SGraphPinColor, InPin);
				}
				else if ((InPin->PinType.PinSubCategoryObject == VectorStruct) || (InPin->PinType.PinSubCategoryObject == RotatorStruct))
				{
					return SNew(SGraphPinVector, InPin);
				}
				else if (InPin->PinType.PinSubCategoryObject == Vector2DStruct)
				{
					return SNew(SGraphPinVector2D, InPin);
				}
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_Byte)
			{
				// Check for valid enum object reference
				return SNew(SGraphPinInteger, InPin);
			}
			else if (InPin->PinType.PinCategory == K2Schema->PC_MCDelegate)
			{
				return SNew(SGraphPinString, InPin);
			}
		}

		// If we didn't pick a custom pin widget, use an uncustomized basic pin
		return SNew(SGraphPin, InPin);
	}
};
